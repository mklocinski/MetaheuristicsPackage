#' @title Traveling Sales Problem
#' @description
#' Calculates total distance traveled in traveling salesman problem given specific node order and matrix of edge values.
#'
#' @details
#' This function does not find the optimal path.
#'
#' @param solution_list a string of characters.
#' @param round_trip (Optional) Boolean; is the path a round trip or does it end without returning.
#'
#' @returns the total distance traveled.
#' @export
traveling_salesman <- function(solution_list, round_trip = T) {
  # Set up solution and trips
  trips <- matrix_setup(solution_list[[2]], row_sum_check = F)
  s <- lapply(string_to_list(solution_list[[1]]), as.numeric)

  if (round_trip) {
    full_trip <- append(s, s[[1]])
  } else {
    full_trip <- s
  }

  # Validity check
  rows <- 1:dim(trips)[1]
  valid_solution_length <- length(s) == length(rows)
  stopifnot(valid_solution_length)

  # Create path
  to <- sapply(1:(length(full_trip) - 1), function(x) full_trip[x])
  from <- sapply(1:(length(full_trip) - 1), function(x) full_trip[x + 1])
  path <- Map(c, to, from)
  distances <- sapply(path, function(x) trips[x[1], x[2]])
  total_distance <- sum(distances)

  return(total_distance)
}



#' @title job
#' @description
#' Creates a single job for a job shop process.
#' @details
#' This function takes in a list of job information that includes p (job length), d (due date), and
#' w (weight for delays).
#'
#' @param job_info a list of job information.
#'
#' @returns a list (job object) to be used by 'job_shop'.
#' @export
job <- function(job_info) {
  return(list(
    p = job_info[2],
    d = job_info[3], w = job_info[4]
  ))
}

#' @title one machine, n jobs
#' @description
#' Conducts a one machine, n jobs process.
#' @details
#' Requires a list of job objects (i.e. list of lists of job information) generated by
#' 'job()'.
#'
#' @param jobs a list of job objects.
#' @param machines (Optional) number of machines; default is obviously 1
#' @param delay (Optional) used if a delay needs to be added to the whole process.
#'
#' @returns a list object that contains the total process time (machine_time) and the
#' total weighted delay (total_weighted_delay).
#' @export
one_machine_n_jobs <- function(jobs, machines = 1, delay = 0) {
  previous_job <- list(p = 0 + delay, d = 0, w = 0)
  previous_completion <- previous_job$p
  machine_time <- 0 + delay
  total_weighted_delay <- 0

  for (job_info in jobs) {
    current_job <- job(job_info)
    current_completion <- previous_completion + current_job$p
    current_delay <- max(c(current_completion - current_job$d, 0))
    current_weighted_delay <- current_delay * current_job$w

    machine_time <- machine_time + current_job$p
    total_weighted_delay <- total_weighted_delay + current_weighted_delay

    previous_job <- current_job
    previous_completion <- previous_completion + current_job$p
    previous_delay <- max(c(current_job$p - current_job$d, 0))
    previous_weighted_delay <- current_delay * current_job$w
  }

  return(list(
    machine_time = machine_time,
    total_weighted_delay = total_weighted_delay
  ))
}


#' @title m machines, n jobs
#' @description
#' Conducts an m machine, n jobs process.
#' @details
#' Requires a list of job objects (i.e. list of lists of job information) generated by
#' 'job()'. Uses function 'next_in_line()' to determine which queue the next job should be sent to.
#'
#' @param jobs a list of job objects.
#' @param machines the number of machines in the process.
#' @param min_max (Optional) Used to specify whether the next-queue decision should be based on
#' maximum (default) or minimum total queue value.
#'
#' @returns a list object that contains the total process time (machine_time) and the
#' total weighted delay (total_weighted_delay).
#' @export
m_machines_n_jobs <- function(jobs, machines, min_max = 1) {
  machines <- as.list(1:machines)
  schedule <- next_in_line(jobs, machines, min_max)
  results <- list()
  for (queue in schedule) {
    job_ids <- names(queue)
    process <- one_machine_n_jobs(jobs[job_ids])
    results[[length(results) + 1]] <- process
  }

  machine_time <- sum(unlist(sapply(results, function(x) x["machine_time"])))
  total_weighted_delay <- sum(unlist(sapply(results, function(x) x["total_weighted_delay"])))

  return(list(
    machine_time = machine_time,
    total_weighted_delay = total_weighted_delay
  ))
}


#' @title m machines, n jobs (flow)
#' @description
#' Conducts an m machine, n jobs process in which the jobs enter the i+1th machine after
#' completing in the ith machine.
#'
#' @details
#' Requires a list of job objects (i.e. list of lists of job information) generated by
#' 'job()'.
#'
#' @param jobs a list of job objects.
#' @param machines the number of machines in the process.
#' @param min_max (Optional) Used to specify whether the next-queue decision should be based on
#' maximum (default) or minimum total queue value.
#'
#' @returns a list object that contains the total process time (machine_time) and the
#' total weighted delay (total_weighted_delay).
#' @export
m_machines_n_jobs_flow <- function(jobs, machines, min_max = 1) {
  first_processing_time <- jobs[[1]][2]
  subsequent_delays <- (length(machines) - 1) * first_processing_time
  results <- list()

  process <- one_machine_n_jobs(jobs, delay = subsequent_delays)

  return(process)
}


#' @title Job Shop Problem
#' @description
#' Conducts the entire job shop process, from job object creation to total weighted delay calculations.
#'
#' @details
#' Given a parameter list of job shop information, creates job objects and sends them
#' through the user-specified job shop type function.
#'
#' Does not provide an optimal solution.
#'
#' @param param_list a list of job shop parameters, including (and in this order) the initial
#' solution string; a matrix of job information with column order job ID, p (processing time), d (due date),
#' and w (weight for delays); number of machines; and job shop type in a string.
#'
#' @returns a list object that contains the total process time (machine_time) and the
#' total weighted delay (total_weighted_delay).
#' @export
job_shop <- function(param_list) {
  s <- lapply(string_to_list(param_list[[1]]), as.numeric)
  jobs <- lapply(s, function(x) param_list[[2]][x, ])
  names(jobs) <- unlist(s)
  process <- param_list[[5]](jobs, param_list[[4]])

  return(process$total_weighted_delay)
}


#' @title Set Covering Problem
#' @description
#' Calculates value of a specific solution to a set covering problem.
#'
#' @details
#' Creates a list of nodes that meet the minimum value criteria (valid), creates a path
#' through the valid nodes, then calculates the value of the valid nodes.
#'
#' Does not provide an optimal solution.
#'
#' @param param_list a list of job shop parameters, including (and in this order) the initial
#' solution string; a matrix of set covering problem information; the maximum node value for
#' inclusion in the set; the penalty to apply per uncovered node.
#'
#' @importFrom magrittr %>%
#' @returns the value of the valid nodes.
#' @export
set_covering <- function(param_list) {
  # Format solution string
  s <- string_to_bool(param_list[[1]])
  set_names <- list()
  # Set penalties
  penalty <- param_list[[4]]

  # Create labeled set matrix
  set <- matrix_setup(param_list[[2]], row_sum_check = F)
  # Identify cities within the given radius
  valid <- apply(set, 1, function(x) ifelse(x <= param_list[[3]], T, F))
  if (length(set_names) > 0) {
    labs <- set_names
  } else {
    labs <- colnames(set)
  }

  # Create list of cities within each city's valid radius
  covered <- which(valid, arr.ind = T) %>% as.data.frame()
  from <- sapply(covered$row, function(x) labs[x])
  to <- sapply(covered$col, function(x) labs[x])
  covered_list <- lapply(labs, function(x) to[which(from == x)])
  names(covered_list) <- labs
  total <- length(unlist(covered_list[s]))

  # Get total uncovered cities
  uncovered <- length(setdiff(labs, unique(unlist(covered_list[s]))))
  val <- (total * 1) - (uncovered * penalty)

  # Calculate number of stations for the solution, penalizing the
  # solution if it results in a negative value (i.e. has uncovered
  # cities)
  obj_val <- ifelse(val < 0, 999, sum(s))
  return(obj_val)
}

#' @title Job Assignment Problem
#' @description
#' Calculates total set up times for given job assignments.
#'
#' @details
#' Pending
#' @export
job_assignment <- function(param_list) {
  s <- unlist(lapply(string_to_list(param_list[[1]]), as.numeric))
  times <- sapply(1:length(s), function(x) param_list[[2]][x, s[x]])

  return(sum(times))
}



#' @title Job Shop - Flow
#' @description
#' Conducts the entire flow job shop process.
#'
#' @details
#' Pending
#'
#' Does not provide an optimal solution.
#'
#' @param param_list a list of job shop parameters, including (and in this order) the initial
#' solution string; job IDs  p (processing time), d (due date),
#' and w (weight for delays); number of machines.
#'
#' @returns a list object that contains job completion information for each job
#' and the weighted delays
#' @export
conduct_flow_jobs <- function(param_list) {
  jobs <- sapply(string_to_list(param_list[[1]]), as.numeric)
  remaining_jobs <- jobs
  completed_jobs <- list()
  start <- 0
  while (length(completed_jobs) < length(jobs)) {
    for (j in 1:length(jobs)) {
      proc <- list()
      for (m in 1:length(param_list[[2]])) {
        if (length(completed_jobs) > 0) {
          last_job_end <- completed_jobs[[j - 1]][[m]][4]
          if (length(proc) > 0) {
            last_mach_end <- proc[[m - 1]][4]
            start <- max(last_job_end, last_mach_end)
          } else {
            start <- last_job_end
          }
        } else {
          start <- start
        }
        end <- start + param_list[[3]][jobs[j]]
        proc[[length(proc) + 1]] <- c(jobs[j], m, start, end)

        start <- end
      }
      # conduct_jobs(remaining_jobs, machines, process_times)
      completed_jobs[[length(completed_jobs) + 1]] <- c(proc)
      remaning_jobs <- remaining_jobs[remaining_jobs != j]
    }
  }

  completed_jobs <- lapply(completed_jobs, function(x) do.call("rbind", x))
  weighted_delay <- list()
  for (c in completed_jobs) {
    complete <- max(c[, 4])
    delay <- max((complete - param_list[[4]][c[1, 1]]), 0)
    weighted_delay[[length(weighted_delay) + 1]] <- delay * param_list[[5]][c[1, 1]]
  }

  print(completed_jobs)
  return(sum(unlist(weighted_delay)))
}

#' @title ATC Index Function
#' @description
#' Pending
#'
#' @details
#' Pending
#' @export
atc_rank <- function(t, p, mp, d, w, K) {
  i <- (w / p) * exp(-((max((d - p - t), 0)) / K * mp))
  return(i)
}

#' @title ATC Job Flow
#' @description
#' Pending
#'
#' @details
#' Pending
#' @export
atc_job_flow <- function(first_job, jobs, machines, process_times, due_dates, weights, K) {
  next_job <- first_job
  remaining_jobs <- jobs
  completed_jobs <- list()
  start <- 0
  while (length(completed_jobs) < length(jobs)) {
    proc <- list()
    for (m in 1:length(machines)) {
      if (length(completed_jobs) > 0) {
        last_job_end <- completed_jobs[[length(completed_jobs)]][[m]][4]
        if (length(proc) > 0) {
          last_mach_end <- proc[[m - 1]][4]
          start <- max(last_job_end, last_mach_end)
        } else {
          start <- last_job_end
        }
      } else {
        start <- start
      }

      end <- start + process_times[next_job]
      proc[[length(proc) + 1]] <- c(next_job, m, start, end)

      start <- end
    }
    completed_jobs[[length(completed_jobs) + 1]] <- c(proc)
    remaining_jobs <- remaining_jobs[remaining_jobs != next_job]
    if (length(remaining_jobs) > 0) {
      get_atc <- sapply(remaining_jobs, function(x) atc_rank(end, process_times[x], mean(process_times), due_dates[x], weights[x], K))
      next_job <- remaining_jobs[match(max(get_atc), get_atc)]
    }
  }

  completed_jobs <- lapply(completed_jobs, function(x) do.call("rbind", x))
  weighted_delay <- list()
  for (c in completed_jobs) {
    complete <- max(c[, 4])
    delay <- max((complete - due_dates[c[1, 1]]), 0)
    weighted_delay[[length(weighted_delay) + 1]] <- delay * weights[c[1, 1]]
  }

  print(completed_jobs)
  return(sum(unlist(weighted_delay)))
}
